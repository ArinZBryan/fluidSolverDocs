If using `Destinations.ImageSequence`, while an image is created for each frame, it is not properly copied to a `byte[]` so that it can be saved as a file.

One clue as to what is happening is the actual file that is output at the end: A grey texture. Importantly, it *is* a valid PNG or JPG image. This rules out the possibility that the encoding stage of the image is where things have gone wrong. Looking towards the copying of the image, grey `Texture2D` instances are actually quite common; they occur, when a texture has been initialised, but no image data has been drawn into it. This means that `Graphics.CopyTexture()` is not doing what we want.
### `Graphics.CopyTexture()`
If we look a little closer into the documentation for this function, we see that it is actually making a call for the GPU to copy the texture data in VRAM. This means that though the copy is happening, it never makes it to the CPU, which is needed to encode the image into a valid file format. So how can this be fixed? By using `Texture2D.ReadPixels()`, we can read pixels into a `Texture2D` on the CPU. The only problem here is that there is no option to read from any old `UnityEngine.RenderTexture`, it *must* be the active `RenderTexture`. As we don't want to modify any data that isn't ours, we must first make a copy of the active `RenderTexture` before setting our own texture as active, performing the copy, and applying to the CPU texture. Now we can reset the active `RenderTexture` back to the old one, and continue with encoding the image, entirely on the CPU.